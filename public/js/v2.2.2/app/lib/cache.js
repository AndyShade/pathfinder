define([],()=>{"use strict";class AbstractStrategy{constructor(){if(new.target===AbstractStrategy)throw new TypeError("Cannot construct AbstractStrategy instances directly")}static create(){return new this}}class StrategyFIFO extends AbstractStrategy{valueToCompare(t){return t.age()}compare(t,e){return e-t}}class StrategyLFU extends AbstractStrategy{valueToCompare(t){return t.hitCount}compare(t,e){return t-e}}class StrategyLRU extends AbstractStrategy{valueToCompare(t){return t.hits[t.hits.length-1]||t.set}compare(t,e){return t-e}}class CacheEntryMeta{constructor(t,e){this._ttl=t,this._tSet=e||this.constructor.now(),this._tHits=[]}get set(){return this._tSet}get hits(){return this._tHits}get hitCount(){return this.hits.length}newHit(t){this._tHits.push(t||this.constructor.now())}age(t){return(t||this.constructor.now())-this._tSet}expired(t){return!(this._ttl<0)&&this._ttl<this.age(t)}static now(){return(new Date).getTime()/1e3}static create(t,e){return new this(t,e)}}class Cache{constructor(t={}){this._config=Object.assign({},Cache.defaultConfig,t),this._store=new Map,this._metaStore=new WeakMap,this._strategy=this.constructor.setStrategy(this._config.strategy),this.debug=((t,...e)=>{this._config.debug&&((e=e||[]).unshift(this._config.name),console.debug("debug: CACHE %o | "+t,...e))}),this.debug("New Cache instance")}get size(){return this._store.size}isFull(){return this.size>=this._config.maxSize}set(t,e,s){this._store.has(t)?(this.debug("SET key %o, UPDATE value %o",t,e),this._store.set(t,e)):(this.debug("SET key %o, NEW value %o",t,e),this.isFull()&&(this.debug(" ↪ FULL trim cache…"),this.trim(this.trimCount(1))),this._store.set(t,e)),this._metaStore.set(e,CacheEntryMeta.create(s||this._config.ttl))}get(t){if(this._store.has(t)){let e=this._store.get(t);if(e){let s=this._metaStore.get(e);if(!s.expired())return this.debug("HIT key %o",t),s.newHit(),e;this.debug("EXPIRED key %o delete",t),this.delete(t)}}this.debug("MISS key %o",t)}getOrDefault(t,e){return this.get(t)||e}keysForTrim(t){let e=[],s=[];for(let[r,i]of this._store){let a=this._metaStore.get(i);if(a.expired()){if(e.push(r),t===e.length)break}else s.push({key:r,value:this._strategy.valueToCompare(a)})}let r=t-e.length;return r>0&&(s=s.sort((t,e)=>this._strategy.compare(t.value,e.value)),e=e.concat(s.splice(0,r).map(t=>t.key))),e}keys(){return this._store.keys()}delete(t){return this._store.delete(t)}clear(){this._store.clear()}trimCount(t){let e=Math.max(Math.round(this._config.maxSize/100*this._config.bufferSize),t);return Math.min(Math.max(this.size-this._config.maxSize+e,0),this.size)}trim(t){if(t>0){let e=this.keysForTrim(t);t>e.length&&console.warn(" ↪ Failed to trim(%i) entries. Only %i in store",t,this.size),this.debug(" ↪ DELETE min %i keys: %o",t,e),e.forEach(t=>this.delete(t))}}status(){return{config:this._config,store:this._store,metaStore:this._metaStore}}static setStrategy(t){switch(t){case"FIFO":return StrategyFIFO.create();case"LFU":return StrategyLFU.create();case"LRU":return StrategyLRU.create();default:throw new ReferenceError("Unknown cache strategy name: "+t)}}}return Cache.defaultConfig={name:"Default",ttl:3600,maxSize:600,bufferSize:10,strategy:"FIFO",debug:!1},Cache});
//# sourceMappingURL=cache.js.map
